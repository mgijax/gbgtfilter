package org.jax.mgi.app.gbgtfilter;

import org.jax.mgi.dbs.mgd.lookup.VocabKeyLookup;
import org.jax.mgi.dbs.mgd.lookup.CoordMapFeatureKeyLookup;
import org.jax.mgi.dbs.mgd.VocabularyTypeConstants;
import org.jax.mgi.dbs.mgd.MGITypeConstants;
import org.jax.mgi.shr.config.GBGeneTrapFilterCfg;
import org.jax.mgi.shr.dbutils.DataIterator;
import org.jax.mgi.shr.dla.input.SequenceInput;
import org.jax.mgi.shr.dla.log.DLALogger;
import org.jax.mgi.shr.dla.input.genbank.GBOrganismChecker;
import org.jax.mgi.shr.dla.input.genbank.GBInputFile;
import org.jax.mgi.shr.dla.input.genbank.GBFormatInterpreter;
import org.jax.mgi.shr.exception.MGIException;
import org.jax.mgi.shr.cache.KeyNotFoundException;
import org.jax.mgi.dbs.mgd.lookup.TranslationException;
import org.jax.mgi.shr.cache.CacheConstants;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Vector;
import java.util.ArrayList;
import java.util.regex.*;

/**
 * @is an application that filters gene trap sequences from GenBank format 
 * sequence records from a set of creators determined by a controlled vocab
 * and writes them to a file
 * @has logger for logging to the four standard log files, an iterator over
 * the input, an output file writer
 * @assumes
 * @does knows how to parse GenBank format files to find Gene Trap sequences
 * and write the full sequence record to a file
 * Relies on the GBFormatInterpretor from the DLA library to parse the sequence
 * record initially, then parses further to determine  whether sequence is a
 * genetrap and from what creator.
 * @company The Jackson Laboratory
 * @author sc
 *
 */

public class GBGeneTrapFilter {

    /**
     * A DataLoadLogger instance for sending messages to the three standard
     * log files.
     */
    private DLALogger logger = null;

    // iterator over an input file
    private DataIterator iterator;

    // configurator
    private GBGeneTrapFilterCfg config;

    // writer for new (no ALO in the database) gene trap sequence records
    BufferedWriter newGeneTrapWriter;

    // writer for all gene trap sequence records
    BufferedWriter allGeneTrapWriter;

    // lookup creator for sequence record to see if it is in the set of
    // creators we want. This lookup has a Translation
    private VocabKeyLookup creatorLookup;
 
    // look up a Map Feature objectId to get a Map Feature key for a given collection
    private CoordMapFeatureKeyLookup featureLookup;
    
    // name of the collection
    private String collectionName;

    // filter mode
    private String filterMode;

    // current number of sequence records written  to the all gene trap file
    private int allGenetrapCtr = 0;

    // current number of sequence records written to the new gene trap file
    private int newGenetrapCtr = 0;

    // expression string, pattern, and matcher to find the class
    // section of a GenBank format COMMENT section
    private static final String CLASS_EXPRESSION = "Class: ([\\s\\S]*?)[\\.|\\n]";
    private Pattern classPattern;
    private Matcher classMatcher;

    // String to determine that a sequence is a gene trap from the Class line
    private static final String GT_EXPRESSION = "Gene Trap";

    // expression string, pattern, and matcher to find the contact
    // section of a GenBank format COMMENT section
    private static final String CONTACT_EXPRESSION = "Contact:([\\s\\S]*?)\\n";
    private Pattern contactPattern;
    private Matcher contactMatcher;

    // String expression to determine a TIGM gene trap from the Contact line
    private static final String TIGM_EXPRESSION =
        "Richard H. Finnell at Texas Institute for Genomic Medicine";

    // String expression to determine  some Ishida gene traps 
    private static final String ISHIDA_EXPRESSION =
	"Kaoru Fukami-Kobayashi RIKEN,";
    // String to find EGTC contact information
    // from section of a GenBank format COMMENT section
    private static final String EGTC_STRING = "Exchangeable Gene Trap Clones";
    // String to id EGTC contact from a record (but not all EGTC have this)
    private static final String EGTC_RAW_CONTACT = 
	"Masatake Araki Kumamoto University,";

    // New line
    private static final String NL = "\n";

    // GenBank Record COMMENT example
    /*
    COMMENT     Contact: BayGenomics
        Bay Area Functional Genomics Consortium (BayGenomics)
        Email: info@baygenomics.ucsf.edu
        Sequence tag generated by 5' RACE of total RNA from gene trap ES
        cell line. ES cell lines harboring insertion mutation of target
        gene are available upon request from BayGenomics. Annotation
        information available from
        http://baygenomics.ucsf.edu/cgi-bin/BaySearch.py?OPTION=EXACT&TYPE=CELL_LINE&KEY=YTA372
        Class: Gene Trap.
    */
     // GenBank Record EGTC COMMENT example (Contact not preceded by "Contact:")
    /*
    COMMENT     Exchangeable Gene Trap Clones
        E-mail: egtc@gtc.gtca.kumamoto-u.ac.jp
        Sequence tag generated by 5'RACE of mRNA from gene trap ES cell
        line. ES cell lines harboring insertion mutation of target gene are
        available upon request from EGTC (Database for the Exchangeable
        Gene Trap Clones).
        Annotation information available from
        http://egtc.jp/show/access/list/detail/index?id1=21&id3=T&id2=92
        Cell line ID: 21-T92
        Class: Gene Trap.
        GSS name: Ayu21-T92.
    */

   /**
    * create logger, lookups, an iterator over the input file and
    * a writer for the output file
    * @effects creates a file in a file system
    * @throws MGIException
    */
    protected void initialize() throws MGIException {
        // create the logger
        this.logger = DLALogger.getInstance();

        // create a configuration object
        config = new GBGeneTrapFilterCfg();

	// get the collection name we need create the feature lookup
	collectionName = config.getMapCollectionName();

	// get the filter mode 'add' or 'reload'
	filterMode = config.getFilterMode();

	// create the creator lookup
	creatorLookup = new VocabKeyLookup(
	    VocabularyTypeConstants.CELLLINE_CREATOR, 
		CacheConstants.FULL_CACHE, CacheConstants.FULL_CACHE);

	// create the feature lookup to determine if we have coords
	// already in the database for this sequence
	featureLookup = new CoordMapFeatureKeyLookup(collectionName, 
		new Integer(MGITypeConstants.SEQUENCE));

        // create an organism checker for the interpreter
        GBOrganismChecker oc = new GBOrganismChecker();

        // create an input file object
        GBInputFile inData = new GBInputFile();

        // create an iterator over the input file with an interpreter
        // that knows how to interpret GenBank records
        iterator = inData.getIterator(new GBFormatInterpreter(oc));

        // create the writers
        try {
            this.newGeneTrapWriter = new BufferedWriter(new FileWriter(config.
                getNewOutputFileName() ));
	    this.allGeneTrapWriter = new BufferedWriter(new FileWriter(config.
                getAllOutputFileName() ));
        }
        catch (IOException e) {
            throw new MGIException(e.getMessage());
        }
        // compile expression to find the class
        classPattern = Pattern.compile(CLASS_EXPRESSION, Pattern.MULTILINE);

        // compile expression to find the contact
        contactPattern = Pattern.compile(CONTACT_EXPRESSION, Pattern.MULTILINE);

    }

    /**
     * iterate through input sequences writing gene trap sequences to a file 
     * @effects creates files/logs in the filesystem
     * @throws MGIException
     */
    protected void run() throws MGIException {
        logger.logdInfo("Filtering Gene Trap Sequences", true);
        // Data object representing the raw values of the current input record
        SequenceInput si;

        // iterate through input file
        while (iterator.hasNext()) {
            try {
                si = (SequenceInput) iterator.next();
                processInput(si);
            }
            // we want to log and continue if we get a RecordFormatException
            catch (MGIException e) {
                logger.logdDebug("Caught MGIException" + e.getName());
                if (e.getParent().getClass().getName().equals(
                    "org.jax.mgi.shr.ioutils.RecordFormatException")) {
                    logger.logdErr(e.getMessage());
                    logger.logcInfo(e.getMessage(), true);
                    continue;
                }
                else {
                    throw e;
                }
            }
        }
    }

    /**
     * closes the file writer and reports counts
     * @throws MGIException
     */
    protected void postprocess() throws MGIException {
        try {
            newGeneTrapWriter.close();
	    allGeneTrapWriter.close();
            logger.logdInfo("Total Gene Trap Sequences Found : " +
		allGenetrapCtr, false);
	    logger.logpInfo("Total Gene Trap Sequences Found : " +
                allGenetrapCtr, false);
	    if (filterMode.equals("add")) {
		logger.logdInfo("New Gene Trap Sequences Found : " +
		    newGenetrapCtr, false);
		logger.logpInfo("New Gene Trap Sequences Found : " +
		    newGenetrapCtr, false);
	    }
        }
        catch (IOException e) {
            throw new MGIException(e.getMessage());
        }
    }

    /**
     * The main routine which dynamically instantiates an instance
     * of this GBGeneTrapFilter and calls the initialize, run, and
     * postProcess methods.
     * @effects the four dla standard log files and output file are written to a
     * file system
     * @effects a database is queried when creating Lookups
     * @param args - no args passed
     */
    public static void main(String[] args) {
        GBGeneTrapFilter filter = new GBGeneTrapFilter();
        try {
            filter.initialize();
            filter.run();
            filter.postprocess();
            System.exit(0);
        }
        catch (MGIException e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    /**
     *
     * @param currentSeqInput - the current sequence we are processing
     * @throws MGIException
     */

    private void processInput(SequenceInput currentSeqInput) 
	    throws MGIException{
        // get the primary seqid of the sequence we are processing
        String seqId = currentSeqInput.getPrimaryAcc().getAccID();

        // true if this is a gene trap sequence
        boolean isGeneTrap = false;

        // the gene trap contact
        String contact = null;

        // get the COMMENT section
        String comment = currentSeqInput.getSeq().getComment();

        // get the full sequence record
        String record = currentSeqInput.getSeq().getRecord();
	
        // determine if this is a gene trap sequence
        isGeneTrap = isGeneTrap(record);

        // parse gene trap info if it is a gene trap sequence
        if (isGeneTrap == true) {
            // get the contact name from which we will be able to determine the
            // creator. Log and continue if we don't find it
	     contact = parseContact(record);
            if (contact == null) {
                logger.logcInfo("SeqID:" + seqId + " has no contact", false);
                return;
            }
            // lookup the creator. Log and continue of
            // we don't find it
	    Integer creator = null;
	    try {
                creator = creatorLookup.lookup(contact);
	    } catch (KeyNotFoundException e) {
		creator = null;
	    } catch (TranslationException e) {
		creator = null;
	    }
            if (creator == null) {
                logger.logcInfo("Contact not in database " +
                                contact + " " +
                                seqId, false);
                return;
            }
            allGenetrapCtr++; 
	    try {
                allGeneTrapWriter.write(record + NL);
            } catch (IOException e) {
                throw new MGIException(e.getMessage());
            }
	    if (filterMode.equals("add")) {
		if (featureLookup.lookup(seqId)== null) {
		    newGenetrapCtr++;
		    try {
			newGeneTrapWriter.write(record + NL);
		    } catch (IOException e) {
			throw new MGIException(e.getMessage());
		    }
		}
		else {
		    logger.logcInfo(seqId + " has coordinate in database", 
			false);
                }
	    }
 	    else {
		try {
		    // we'll be reloading, so write everything to 'new'
		    newGeneTrapWriter.write(record + NL);
		} catch (IOException e) {
		    throw new MGIException(e.getMessage());
		}

	    }
        }
    }

 
    /**
     * get the contact from a section of a GenBank gene trap record
     * @param s - the string from which to determine the contact
     * @return - the gene trap contact
     * @throws MGIException
     */
    private String parseContact(String s)  throws MGIException {
        String c = null;

        // find the contact, if it exists
        contactMatcher = contactPattern.matcher(s);
        if (contactMatcher.find() == true) {
            c = contactMatcher.group(1).trim();
        }
	if ( c != null && c.equals(EGTC_RAW_CONTACT)) {
	     c = EGTC_STRING;
	}
        // if we still didn't find a contact it is probably an EGTC gene trap
	// without the contact
        // search explicitly for the EGTC contact text
        if (c == null) {
            if (s.indexOf(EGTC_STRING) != -1) {
                c = EGTC_STRING;
            }
        }
	
        return c;
    }

    /**
     * Determine if this is a gene trap sequence by searching for
     * "Class: Gene Trap" in the GenBank gene trap record
     * @param record - a GenBank gene trap record
     * @return true if this is a gene trap sequence
     * @throws MGIException
     */
    private boolean isGeneTrap(String record) throws MGIException {
        // find the class
        classMatcher = classPattern.matcher(record);
        boolean isGT = false;
        if (classMatcher.find() == true) {
            String commentClass = classMatcher.group(1);
            if (commentClass.equals(GT_EXPRESSION)) {
                isGT = true;
            }
        }
        else {
            contactMatcher = contactPattern.matcher(record);
            if (contactMatcher.find() == true) {
                String s = contactMatcher.group(1).trim();
                if(s.equals(TIGM_EXPRESSION) || s.equals(ISHIDA_EXPRESSION)) {
                   isGT = true;
                }
            }
        }
        return isGT;
    }
}
